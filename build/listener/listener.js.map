{
  "version": 3,
  "sources": ["../../src/listener/listener.ts"],
  "sourcesContent": ["import { EventEmitter } from \"stream\";\nimport { SamartHomeHandyBis } from \"../main\";\nimport { StateChangedDataPack } from \"../server/datapacks\";\nimport { Mutex } from \"async-mutex\";\n\nexport enum Events {\n    StateChange = \"stateChanged\",\n}\n// eslint-disable-next-line no-unused-vars \nexport class Listener extends EventEmitter {\n    static subscribtionThresholdPerInstance = 50;\n    adapter : SamartHomeHandyBis;\n    busy : boolean = false;\n    subsribedStates: Map<string, {overThreshold: boolean, subscribed: Set<string>, pending: Set<string>}> = new Map();\n    mutex : Mutex = new Mutex();\n    constructor(adapter: SamartHomeHandyBis) {\n        super();\n        this.adapter = adapter;\n    }\n\n    onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state != null) {\n            // The state was changed\n            //this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n            //Check if notification\n            if (!id.startsWith(\"hiob.\")) {\n                const adapaterKey : string = id.split(\".\")[0] + \".\" +  id.split(\".\")[1];\n                if(this.subsribedStates.has(adapaterKey) && this.subsribedStates.get(adapaterKey)!.subscribed.has(id)) {\n                    if (this.adapter.valueDatapoints[id] == null) {\n                        this.adapter.valueDatapoints[id] = {};\n                    }\n                    this.adapter.valueDatapoints[id].val = state.val;\n                    this.adapter.valueDatapoints[id].ack = state.ack;\n                    this.adapter.server?.broadcastMsg(\n                        new StateChangedDataPack(id, state.val, state.ack, state.lc, state.ts).toJSON()\n                    );\n\n                }\n               \n            }\n            this.emit(Events.StateChange, new StateChangeEvent(id, state.val, state.ack));\n        } else {\n            this.emit(\"stateDeleted\", new StateChangeEvent(id, null, null));\n            this.adapter.log.info(`state ${id} deleted`);\n        }\n    }\n    /**\n     * Adds a State id to the pending list\n     * @param id The id of the State you want to subscribe to\n     */\n    addPendingSubscribeState(id: string) : void {\n       this.mutex.runExclusive(async () => {\n        const adapaterKey : string = id.split(\".\")[0] + \".\" +  id.split(\".\")[1];\n        if(this.subsribedStates.has(adapaterKey)) {\n            const t = this.subsribedStates.get(adapaterKey);\n            if(!t!.subscribed.has(id)) {\n                t?.pending.add(id);\n            }\n        } else {\n            this.subsribedStates.set(adapaterKey, {overThreshold: false, subscribed: new Set(), pending:  new Set([id])});\n        }\n       });\n    }\n    /**\n     * Subscribes to all States listed in the pending (see addPendingSubscribeState)\n     * If there are more than 50 subscriptions for one instance it subscribses to all changes inside this instance\n     */\n    subscribeToPendingStates() : void{\n        this.mutex.runExclusive(async () => {\n            for(const [adapaterKey, subsribedStatesStatus] of this.subsribedStates) {\n                if(subsribedStatesStatus.pending.size > 0) {\n                    if(subsribedStatesStatus.overThreshold) {\n                        subsribedStatesStatus.pending.forEach((e) => subsribedStatesStatus.subscribed.add(e));\n                    } else {\n                        const newSubscriptionSize = subsribedStatesStatus.pending.size + subsribedStatesStatus.subscribed.size;\n                        if(newSubscriptionSize >  Listener.subscribtionThresholdPerInstance && !adapaterKey.startsWith(\"alias.\")) {\n                            subsribedStatesStatus.pending.forEach((e) => {\n                                subsribedStatesStatus.subscribed.add(e);\n                            });\n                            this.adapter.log.debug(\"More than 50 states of \" + adapaterKey + \" where subscribed. Now only listening to \" + adapaterKey + \".*\");\n                            //subscribe to adapaterKey.* instead\n                            await this.adapter.subscribeForeignStatesAsync(adapaterKey + \".*\");\n                            //Unsubscribe to the exesting subscriptions\n                            for(const i of subsribedStatesStatus.subscribed) {\n                                this.adapter.unsubscribeForeignStatesAsync(i);\n                            }\n                        } else {\n                            subsribedStatesStatus.pending.forEach((e) => {\n                                subsribedStatesStatus.subscribed.add(e);\n                                this.adapter.subscribeForeignStates(e);\n                            });\n                        }\n                    }\n                    subsribedStatesStatus.pending.clear();\n                }\n            }\n        });\n    }\n}\n\nexport class StateChangeEvent {\n    objectID: string;\n    value: any;\n    ack: any;\n    constructor(\n        objectID: string,\n        value: string | number | boolean | undefined | null,\n        ack: boolean | undefined | null,\n    ) {\n        this.objectID = objectID;\n        this.value = value;\n        this.ack = ack;\n    }\n}\n"],
  "mappings": "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",
  "names": ["Events"]
}
