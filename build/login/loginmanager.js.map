{
  "version": 3,
  "sources": ["../../src/login/loginmanager.ts"],
  "sourcesContent": ["import { Events, StateChangeEvent } from \"../listener/listener\";\nimport { SamartHomeHandyBis } from \"../main\";\nimport { Client } from \"../server/client\";\nimport { LoginApprovedPacket, LoginDeclinedPacket, LoginKeyPacket, RequestLoginPacket } from \"../server/datapacks\";\nimport * as bcrypt from \"bcrypt\"\nimport * as crypto from \"crypto\"\nexport class LoginManager {\n    adapter: SamartHomeHandyBis;\n    pendingClients: Client[];\n\tapproveLogins: boolean = false;\n\tapproveLoginsTimeout?: NodeJS.Timeout;\n    constructor(adapter: SamartHomeHandyBis) {\n        this.adapter = adapter;\n        this.adapter.listener.on(Events.StateChange, this.onStateChange.bind(this));\n        this.pendingClients = []\n    }\n\n    private async onStateChange(event: StateChangeEvent) : Promise<void>  {\n\n\t\tif(event.objectID.startsWith(\"hiob.\")) {\n\t\t\tconst splited = event.objectID.split(\".\");\n\t\t\t//If Datapoint is approved Datapoint\n\t\t\tif(splited.length>4 && splited[2] == \"devices\" && splited[4] == \"approved\") {\n\t\t\t\tconst deviceID = splited[3];\n\t\t\t\t//Get Client from pending list\n\t\t\t\tconst cl = this.pendingClients.find((e) => e.id == deviceID);\n\t\t\t\t//If Approved was set to true\n\t\t\t\tif(cl && event.value) {\n\t\t\t\t\tawait this.setAndSendLoginKeys(deviceID, cl);\n\n\t\t\t\t} else {\n\t\t\t\t\tthis.adapter.log.debug(\"No pending client found\");\n\t\t\t\t}\n\t\t\t} else if(splited[2] == \"approveNextLogins\") {\n\t\t\t\tif(event.value) {\n\t\t\t\t\tif(this.approveLoginsTimeout) {\n\t\t\t\t\t\tclearTimeout(this.approveLoginsTimeout);\n\t\t\t\t\t}\n\t\t\t\t\tthis.approveLogins = true;\n\t\t\t\t\tthis.approveLoginsTimeout = setTimeout(() => {\n\t\t\t\t\t\tthis.approveLogins = false;\n\t\t\t\t\t\tthis.approveLoginsTimeout = undefined;\n\t\t\t\t\t\tthis.adapter.setStateAsync(\"approveNextLogins\", false, true);\n\t\t\t\t\t}, 1000*60)\n\t\t\t\t} else {\n\t\t\t\t\tthis.approveLogins = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\tprivate async setAndSendLoginKeys(deviceID: string , cl: Client) : Promise<void> {\n\t\tconst keys = await this.genKey();\n\t\tawait this.adapter.setStateAsync(\"devices.\" + deviceID + \".key\", keys[1], true);\n\t\tcl.sendMSG(new LoginKeyPacket(keys[0]).toJSON(), false);\n\t}\n\n\tpublic async onLoginRequest(client: Client, loginRequestData: RequestLoginPacket ) : Promise<boolean> {\n        this.adapter.log.debug(\"Client(\" + client.toString() + \") requested to login\")\n        this.pendingClients.push(client);\n        let deviceIDRep = loginRequestData.deviceID.replace(\".\", \"-\");\n\t\twhile(deviceIDRep.includes(\".\")) {\n\t\t\tdeviceIDRep = deviceIDRep.replace(\".\", \"-\");\n\t\t}\n\t\tclient.id = deviceIDRep;\n        this.createObjects(deviceIDRep, loginRequestData.deviceName, loginRequestData.key);\n        this.adapter.subscribeStatesAsync(\"devices.\" + deviceIDRep + \".approved\");\n        this.adapter.setStateAsync(\"devices.\" + deviceIDRep + \".connected\", true, true);\n        if(!await this.validateLoginRequest(client, deviceIDRep, loginRequestData)) {\n            this.loginDeclined(client);\n\t\t\treturn false;\n        }\n\t\tthis.pendingClients.filter((cl, i) => cl != client);\n\t\tclient.onApprove();\n\t\tclient.sendMSG(new LoginApprovedPacket().toJSON(), false);\n\t\treturn true;\n\n\n    }\n\n    private async validateLoginRequest(client: Client, deviceIDRep: string, loginRequestData: RequestLoginPacket) : Promise<boolean>{\n        const approved = await this.adapter.getStateAsync(\"devices.\" + deviceIDRep + \".approved\");\n\t\tconst keyState = await this.adapter.getStateAsync(\"devices.\" + deviceIDRep + \".key\");\n\t\tconst needPWD = await this.adapter.getStateAsync(\"devices.\" + deviceIDRep + \".noPwdAllowed\");\n\t\t//Check if next should be accepted:\n\t\tlet apr = true;\n        if(!approved || !approved.val) {\n            this.adapter.log.debug(\"Login declined for client: \" + client.toString() + \" (\" + loginRequestData.deviceName + \"): not approved\");\n            apr = false;\n        }\n        if(keyState == null || keyState.val == null) {\n            apr = false;\n        }\n\t\tif(!loginRequestData.key) {\n\t\t\tapr = false;\n\t\t}\n\n\t\tif(needPWD && !needPWD?.val) {\n\n\t\t\tif(!loginRequestData.user || !loginRequestData.password || !(await this.adapter.checkPasswordAsync(loginRequestData.user, loginRequestData.password))) {\n\t\t\t\tthis.adapter.log.debug(\"Login declined for client: \" + client.toString() + \" (\" + loginRequestData.deviceName + \"): wrong password\");\n\t\t\t\tapr = false;\n\t\t\t}\n\n\t\t}\n\n\n        if( keyState != null && keyState.val != null && !bcrypt.compare( keyState.val.toString(), loginRequestData.key)) {\n            this.adapter.log.debug(\"Login declined for client: \" + client.toString() + \" (\" + loginRequestData.deviceName + \"): wrong key\");\n           \tapr = false;\n        }\n\t\tif(!apr && this.approveLogins) {\n\t\t\tawait this.adapter.setStateAsync(\"devices.\" + deviceIDRep + \".approved\", true, true);\n\n\t\t\t//Send Login Keys\n\t\t\tawait this.setAndSendLoginKeys(deviceIDRep, client);\n\n\n\t\t\tapr = true;\n\t\t}\n        return apr;\n\n    }\n\n    /**\n     * This method creates all IoBroker Objects needed for the login request. If they exists this method will not create any\n     * @param deviceIDRep Id of the device\n     * @param deviceName Name of the device\n     */\n\n    private async createObjects(deviceIDRep: string, deviceName: string, key: string) : Promise<void>{\n        await this.adapter.setObjectNotExistsAsync(\"devices.\" + deviceIDRep + \".connected\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"Connected\",\n\t\t\t\ttype: \"boolean\",\n\t\t\t\trole: \"indicator.reachable\",\n\t\t\t\tdef: true,\n\t\t\t\tread: true,\n\t\t\t\twrite: false,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\t\tawait this.adapter.setObjectAsync(\"devices.\" + deviceIDRep , {\n\t\t\ttype: \"folder\",\n\t\t\tcommon: {\n\t\t\t\tname: deviceName,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\t\tawait this.adapter.setObjectAsync(\"devices.\" + deviceIDRep + \".name\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"Name\",\n\t\t\t\ttype: \"string\",\n\t\t\t\trole: \"info.name\",\n\t\t\t\tdef: deviceName,\n\t\t\t\tread: true,\n\t\t\t\twrite: false,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\t\tawait this.adapter.setStateAsync(\"devices.\" + deviceIDRep + \".name\", deviceName, true);\n\n\t\tawait this.adapter.setObjectNotExistsAsync(\"devices.\" + deviceIDRep + \".id\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"ID\",\n\t\t\t\ttype: \"string\",\n\t\t\t\trole: \"info.address\",\n\t\t\t\tdef: deviceIDRep,\n\t\t\t\tread: true,\n\t\t\t\twrite: false,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\t\tawait this.adapter.setObjectNotExistsAsync(\"devices.\" + deviceIDRep + \".key\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"Key\",\n\t\t\t\ttype: \"string\",\n\t\t\t\trole: \"key\",\n\t\t\t\tdef: key,\n\t\t\t\tread: false,\n\t\t\t\twrite: false,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\n\t\tawait this.adapter.setObjectNotExistsAsync(\"devices.\" + deviceIDRep + \".lastConnection\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"Last Connection\",\n\t\t\t\ttype: \"number\",\n\t\t\t\trole: \"date\",\n\t\t\t\tdef: Date.now(),\n\t\t\t\tread: true,\n\t\t\t\twrite: true,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\t\tthis.adapter.setState(\"devices.\" + deviceIDRep + \".lastConnection\", Date.now())\n\n\n\t\tawait this.adapter.setObjectNotExistsAsync(\"devices.\" + deviceIDRep + \".approved\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"Approved\",\n\t\t\t\ttype: \"boolean\",\n\t\t\t\trole: \"indicator\",\n\t\t\t\tdef: false,\n\t\t\t\tread: true,\n\t\t\t\twrite: true,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\t\tawait this.adapter.setObjectNotExistsAsync(\"devices.\" + deviceIDRep + \".noPwdAllowed\", {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: \"No Pwd Allowed\",\n\t\t\t\ttype: \"boolean\",\n\t\t\t\trole: \"indicator\",\n\t\t\t\tdef: false,\n\t\t\t\tread: true,\n\t\t\t\twrite: true,\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n    }\n\n    private genRandomString(length: number) : string {\n\t\tlet result           = \"\";\n\t\tconst characters       = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-\\\\/&%$!;<>*+#\";\n\t\tconst charactersLength = characters.length;\n\t\tfor ( let i = 0; i < length; i++ ) {\n\t\t\tresult += characters.charAt(crypto.randomInt(0, charactersLength));\n\t\t}\n\t\treturn result;\n\t}\n\n    private async genKey() : Promise<[string, string]> {\n\t\tconst key = this.genRandomString(512);\n\t\tconst hashedKey = await bcrypt.hash(key, 5);\n        return [key, hashedKey];\n    }\n\n    private loginDeclined(client: Client) : void {\n        client.sendMSG(new LoginDeclinedPacket().toJSON(), false);\n    }\n\n}"],
  "mappings": "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",
  "names": []
}
