{
  "version": 3,
  "sources": ["../../src/server/server.ts"],
  "sourcesContent": ["import * as ws from \"ws\"\nimport * as fs from \"fs\"\nimport { createServer } from \"https\";\nimport * as m from \"../main\";\nimport { Client } from \"./client\";\nimport { IncomingMessage } from \"http\";\nimport { FirstPingPack } from \"./datapacks\";\nexport class Server {\n   certPath: string;\n   keyPath: string;\n   useCert: boolean;\n   port: number;\n   adapter: m.SamartHomeHandyBis;\n   socket: ws.Server | undefined;\n   stoped: boolean = false;\n   conClients : Client[] = [];\n   constructor(port: number = 4500, keyPath: string = \"key.pem\", certPath: string = \"cert.pem\", adapter: m.SamartHomeHandyBis, useCert: boolean = false) {\n      this.port = port;\n      this.certPath = certPath;\n      this.keyPath = keyPath;\n      this.adapter = adapter;\n      this.useCert = useCert;\n   }\n\n\n   startServer() : void {\n      let server\n      \n\n      if(this.useCert) {\n         server = createServer({\n            cert: fs.readFileSync(this.certPath),\n            key: fs.readFileSync(this.keyPath),\n         });\n         this.adapter.log.info(\"[Server] Starting secure server...\")\n         this.socket = new ws.Server({server: server})\n      } else {\n         this.adapter.log.info(\"[Server] Starting server...\")\n         this.socket = new ws.Server({port: this.port})\n      }\n      this.socket.on(\"error\", (e) =>  {this.adapter.log.info(\"error: \" + e.message); this.adapter.setState(\"info.connection\", false, true);} );\n      this.adapter.setState(\"info.connection\", true, true);\n      this.socket.on(\"connection\", (socket: ws.WebSocket, req) => {\n          this.adapter.log.debug(\"Client connected\");\n          this.conClients.push(new Client(socket, this, req, this.adapter));\n          socket.send(new FirstPingPack().toJSON());\n      });\n      server?.listen(this.port);\n      this.adapter.log.info(\"Server started and is listening on port: \" + this.port);\n      this.stoped = false;\n\n\n   }\n\n   broadcastMsg(msg: string) :void  {\n      //this.webSocketServer.clients.forEach((e) => {});\n      this.conClients.forEach((element) => {if(element.isConnected) element.sendMSG(msg, true);});\n  }\n\n  stop() : void {\n   //TODO: Stop server\n   this.socket?.close()\n   this.adapter.log.info(\"Server stoped\");\n   this.stoped = true;\n}\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,SAAoB;AACpB,mBAA6B;AAE7B,oBAAuB;AAEvB,uBAA8B;AACvB,MAAM,OAAO;AAAA,EASjB,YAAY,OAAe,MAAM,UAAkB,WAAW,WAAmB,YAAY,SAA+B,UAAmB,OAAO;AAFtJ,kBAAkB;AAClB,sBAAwB,CAAC;AAEtB,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,EAClB;AAAA,EAGA,cAAqB;AAClB,QAAI;AAGJ,QAAG,KAAK,SAAS;AACd,mBAAS,2BAAa;AAAA,QACnB,MAAM,GAAG,aAAa,KAAK,QAAQ;AAAA,QACnC,KAAK,GAAG,aAAa,KAAK,OAAO;AAAA,MACpC,CAAC;AACD,WAAK,QAAQ,IAAI,KAAK,oCAAoC;AAC1D,WAAK,SAAS,IAAI,GAAG,OAAO,EAAC,OAAc,CAAC;AAAA,IAC/C,OAAO;AACJ,WAAK,QAAQ,IAAI,KAAK,6BAA6B;AACnD,WAAK,SAAS,IAAI,GAAG,OAAO,EAAC,MAAM,KAAK,KAAI,CAAC;AAAA,IAChD;AACA,SAAK,OAAO,GAAG,SAAS,CAAC,MAAO;AAAC,WAAK,QAAQ,IAAI,KAAK,YAAY,EAAE,OAAO;AAAG,WAAK,QAAQ,SAAS,mBAAmB,OAAO,IAAI;AAAA,IAAE,CAAE;AACvI,SAAK,QAAQ,SAAS,mBAAmB,MAAM,IAAI;AACnD,SAAK,OAAO,GAAG,cAAc,CAAC,QAAsB,QAAQ;AACxD,WAAK,QAAQ,IAAI,MAAM,kBAAkB;AACzC,WAAK,WAAW,KAAK,IAAI,qBAAO,QAAQ,MAAM,KAAK,KAAK,OAAO,CAAC;AAChE,aAAO,KAAK,IAAI,+BAAc,EAAE,OAAO,CAAC;AAAA,IAC5C,CAAC;AACD,qCAAQ,OAAO,KAAK;AACpB,SAAK,QAAQ,IAAI,KAAK,8CAA8C,KAAK,IAAI;AAC7E,SAAK,SAAS;AAAA,EAGjB;AAAA,EAEA,aAAa,KAAoB;AAE9B,SAAK,WAAW,QAAQ,CAAC,YAAY;AAAC,UAAG,QAAQ;AAAa,gBAAQ,QAAQ,KAAK,IAAI;AAAA,IAAE,CAAC;AAAA,EAC9F;AAAA,EAEA,OAAc;AA3DhB;AA6DG,eAAK,WAAL,mBAAa;AACb,SAAK,QAAQ,IAAI,KAAK,eAAe;AACrC,SAAK,SAAS;AAAA,EACjB;AACA;",
  "names": []
}
